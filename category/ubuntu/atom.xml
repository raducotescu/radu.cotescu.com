<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ubuntu | Radu Cotescu's professional blog]]></title>
  <link href="https://radu.cotescu.com/category/ubuntu/atom.xml" rel="self"/>
  <link href="https://radu.cotescu.com/"/>
  <updated>2014-12-19T13:59:48+02:00</updated>
  <id>https://radu.cotescu.com/</id>
  <author>
    <name><![CDATA[Radu Cotescu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remapping Keys in Ubuntu 14.04]]></title>
    <link href="https://radu.cotescu.com/remapping-keys-in-ubuntu-14.04/"/>
    <updated>2014-09-07T18:30:00+03:00</updated>
    <id>https://radu.cotescu.com/remapping-keys-in-ubuntu-14.04</id>
    <content type="html"><![CDATA[<p>Ever since I've switched to Mac OS X I liked its shortcut modifiers more than the ones available on Windows / Linux. While I do agree that sometimes
you lose count of the number of modifier keys that you have to press in order to get something done, most of the cases that claim is just FUD.</p>

<p>The ergonomy of the Mac has also made its way into how shortcuts are defined. The <code>Command</code> key, positioned where <code>Alt</code> is on PC keyboards, is
definitely better positioned when it comes to using that key as your main modifier for shortcuts. Call it the power of habit, but every time I
switch to a PC I find myself pressing the <code>Alt</code> key instead of <code>Control</code>. And that's because <code>Alt</code> is in a handier position.</p>

<!--more-->


<p>A few weeks ago I bought a <a href="http://www.wasdkeyboards.com/index.php/products/code-keyboard/code-87-key-mechanical-keyboard.html" title="CODE 87-Key Mechanical Keyboard ">CODE ten-keyless mechanical keyboard</a>.
One of the nifty features (and there are plenty) is the ability to change the layout of your keyboard with a combination of DIP switches located on
the back. Obviously, it can be configured to a Mac layout. But what do you do when you want to use the same keyboard on your Linux box, from time to
time? I mean you're mostly using <code>Command</code> for your shortcuts. Remapping the shortcuts in your head to <code>Control</code> is not that easy at first.</p>

<p><img src="/uploads/2014/09/07/code.jpg" title="CODE 87-Key Mechanical Keyboard with Mac layout" alt="&quot;CODE 87-Key Mechanical Keyboard with Mac layout&quot;" /></p>

<h2>XKB</h2>

<p>Luckily Ubuntu, like many other Linux distros, comes with <code>xkb</code> - the X KeyBoard extension. This extension is responsible for mapping the physical
keys of your keyboard to their designed function. <code>xkb</code> symbol files can be found in <code>/usr/share/X11/xkb/symbols</code> and it's good to know that they're
localised, in case you need to add some language-specific mappings. However, in my case, I need to remap some of the modifier keys.</p>

<p>The modifier keys are mapped in <code>/usr/share/X11/xkb/symbols/pc</code>, a file which is inherited by all other configurations. Since I just want to replace
<code>Super</code> with <code>Control</code>, the changes are minimal:</p>

<p>```bash</p>

<pre><code>key &lt;LCTL&gt; {    [ Super_L       ]   };
key &lt;LWIN&gt; {    [ Control_L     ]   };
key &lt;RCTL&gt; {    [ Super_R       ]   };
key &lt;RWIN&gt; {    [ Control_R     ]   };
</code></pre>

<p>```</p>

<p>In order to apply the new mappings you need to clear out <code>xkb</code>'s cache from <code>/var/lib/xkb</code>:</p>

<p>```bash</p>

<pre><code>rm -rf /var/lib/xkb/*
</code></pre>

<p>```</p>

<p>Afterwards just restart your X session and you're good to go. Even though this small change doesn't make all shortcuts to work like on a Mac it's still
a lot better than without it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Switching to Mac from Ubuntu]]></title>
    <link href="https://radu.cotescu.com/the-switch-to-mac-from-ubuntu/"/>
    <updated>2012-05-20T23:39:00+03:00</updated>
    <id>https://radu.cotescu.com/the-switch-to-mac-from-ubuntu</id>
    <content type="html"><![CDATA[<p>When I joined Adobe I was given the chance of choosing between using a Lenovo ThinkPad or a MacBook Pro as my
development machine. Since I really dislike the design of the ThinkPads and also because I really wanted to try a Mac
for a longer period of time I accepted the challenge. My previous experiences with a Mac were limited to only a few
occasions when I had to perform some specific tasks - mostly while dishing Apple and Mac because it took me at least
twice the time I needed to complete the same tasks on a machine running Ubuntu.</p>

<p>After 10 days of using only the MacBook as my main computer (even at home), I can't say that I really miss using Ubuntu.</p>

<!-- more -->


<p>Sure, there are some things that aren't as nice on a Mac:</p>

<ul>
<li><p>the lack of a decent package manager - <strong>MacPorts</strong>, although usable, can't compare with <strong><code>apt-get</code></strong>;</p></li>
<li><p>the lack of a good default text editing application - <strong>TextEdit</strong> sucks compared to <strong>gedit</strong>; however I have
discovered <a href="http://www.sublimetext.com/" title="Sublime Text 2"><strong>Sublime Text 2</strong></a> aka <code>vim</code> on steroids with a GUI;</p></li>
<li><p>the window management system - although I've come to understand why there's no need to maximize a window (hence why
the third window management button is called "zoom"), I really don't like the fact that if you "hide" a window
(minimize it in plain English), you have to right-click on its icon from the dock to restore it;</p></li>
<li><p><strong>Terminal</strong> is not that smart by default - more info <a href="http://blog.macromates.com/2006/word-movement-in-terminal/" title="Word Movement in Terminal">here</a>; also, because I often perform tasks from the terminal I needed a way to make the app on
the Mac behave more like <a href="http://en.wikipedia.org/wiki/Yakuake" title="Yakuake"><strong>Yakuake</strong></a> and that's how I found out about
<a href="http://totalterminal.binaryage.com/" title="TotalTerminal"><strong>TotalTerminal</strong></a>;</p></li>
<li><p><strong>Finder</strong>, the file browser on the Mac, is not really worthy of "the world's most advanced desktop operating system";
it lacks tabs, the <code>cut</code> function is not enabled (although it is available) and if you enable it anything you "cut" will
make it to <strong>Trash</strong>.</p></li>
</ul>


<p>I had no problems configuring the system and this was probably helped by the changes that were made in Ubuntu in this
direction over the previous years. An Ubuntu user would have no problems at all adjusting to the Mac; and the other way
around. This was a bold decision - to use the Mac as the source of inspiration for Ubuntu - and I really appreciate Mark
Shuttleworth's leadership in the project. Although I really like the idea of freedom that the Linux ecosystem promotes,
I do agree that having some restrictions in place - some would call it direction - helps in delivering a product with a
superior quality.</p>

<p>There are a lot of things that I like about the Mac:</p>

<ul>
<li><p>the hardware is superior to everything else on the market and by superior I don't mean necessarily performance-wise;
everything fits together so good that nothing seems out of place; the attention to details was paramount; the fact
that the body is made from Aluminum helps a lot for the overall system cooling - the fan rarely can be heard and that's
only when the CPU is very busy;</p></li>
<li><p>having an illuminated keyboard is really useful when using the laptop in dim light or when you want to work during the
night - such a simple and efficient idea;</p></li>
<li><p>the battery life is very good - if you don't use <strong>Skype</strong> or the <strong>GoogleVoiceAndVideo</strong> plug-in; you can easily
squeeze 4 - 5 hours if you're not performing rocket science; I managed to reach 3.5 hours while coding with Java on top
of a web application that ran continuously in a Servlets container;</p></li>
<li><p>the gestures and the track-pad really increase productivity;</p></li>
<li><p>the GUI - this is where the Mac was, is and will be ahead of the other OSs;</p></li>
<li><p>using a secondary display is as easy as connecting it to the Mini DisplayPort; no other settings have to be made;</p></li>
<li><p>it's a widely (?!) supported Unix or it has better support than any Linux distribution anyway;</p></li>
<li><p>the display (even the one with the 1440x900 resolution) looks sharp from any angle without any colour bleeding.</p></li>
</ul>


<p>If I'd run Mac OS X on any other hardware probably I wouldn't be so amazed (yes, I know about the license). But combine
the OS with the hardware and you get a killer combination that's easy to accept as the norm. It slowly gets you and it
becomes harder and harder to go back to what you were using before. Yes, I have become a
"<a href="http://www.google.com/search?&amp;q=define%3Amactard">mactard</a>".</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrating your Ubuntu machine to a SSD drive]]></title>
    <link href="https://radu.cotescu.com/migrating-your-ubuntu-machine-to-a-ssd-drive/"/>
    <updated>2012-05-11T23:10:00+03:00</updated>
    <id>https://radu.cotescu.com/migrating-your-ubuntu-machine-to-a-ssd-drive</id>
    <content type="html"><![CDATA[<p>SSD drives have finally become affordable and more reliable than they used to be. Partly this was sure helped by the price boost of the traditional hard-disks manufactured in Thailand (I think everybody still reminds the <a href="http://en.wikipedia.org/wiki/2011_Thailand_flood" title="2011 Thailand flood">floods</a> from the summer of 2011). The competition helped the development of innovative solutions and after 4 years since their mass-consumption breakthrough they have managed to become a standard on ultrabooks and premium laptops.</p>

<p>Because the price / GB of the classic mechanical hard-disk was so low (as low as US$0.05 per GB for 3.5 inch drives and US$0.10 per GB for 2.5 inch drives), producers started to offer larger drives for the same money. Unfortunately SSD technologies cannot and probably will not evolve the same way due to memory degradations once the chip size decreases. In particular this led to higher prices for the same disk size, making SSDs more attractive for boot / OS drives instead of plain storage ones.</p>

<p>Migrating a current OS installation usually has to take into consideration that the SSD destination disk might not be able to fully accommodate the previously stored data. The following paragraphs will describe what solutions can be employed in order to successfully migrate an Ubuntu installation (or any other Linux distribution) to a SSD drive.</p>

<!-- more -->


<h1>How To</h1>

<p>Depending on the available storage space of the SSD, there are two available solutions:</p>

<ol>
<li><p>the destination drive is just as big as the source drive, or larger &ndash; <code>ddrescue</code></p></li>
<li><p>the destination drive is smaller than the source drive &ndash; <code>rsync</code>, <code>gparted</code>, <code>boot-repair</code></p></li>
</ol>


<p>Tools needed for both solutions:</p>

<ol>
<li><p>an Ubuntu live CD / live USB stick from which to boot and perform the migration;</p></li>
<li><p>at least two SATA drives, one for the source and one for the destination disk;</p></li>
<li><p>at least two SATA data cables and two SATA power cables if you're using a desktop machine to perform the migration, or a SATA to USB adaptor if you're using a laptop;</p></li>
<li><p>a Philips screwdriver to mount / un-mount the hard drives and possibly the 3.5" adaptor.</p></li>
</ol>


<p>It's time to connect the hard drives to your machine.</p>

<h2>1. Same size or larger SSD</h2>

<p>If the SSD you have installed on your machine is the same size or larger than your current mechanical drive it means that you're rich. Furthermore, the work you have to do to migrate your system to the new drive does not require too much effort. <code>ddrescue</code> is a great tool for restoring information from failing drives but it can also be used to perform bitwise clones.</p>

<p>To start migrating your system from one drive to the other, perform the following steps:</p>

<ol>
<li><p>boot your machine using the live CD / USB stick;</p></li>
<li><p>enable the "universe" repositories on Ubuntu and install <code>gddrescue</code>:</p>

<pre><code> sudo apt-get update &amp;&amp; sudo apt-get install gddrescue
</code></pre></li>
<li><p>use <code>gddrescue</code> to clone your drive:</p>

<pre><code> sudo ddrescue -v --force /dev/sda /dev/sdb
</code></pre>

<p> where <code>/dev/sda</code> is your source drive and <code>/dev/sdb</code> is your destination drive</p></li>
<li><p>have patience; depending on your disk size and your machine's performance this might take a while.</p></li>
</ol>


<p>At the end you should be able to seamlessly replace the old spinning drive with the SSD and just enjoy the snappiness of your system.</p>

<h2>2. Smaller SSD - the usual compromise</h2>

<p>Trying to clone a larger disk to a smaller one using <code>ddrescue</code> is not trivial, even if the total used storage space would be less than the SSD's storage capacity. In this case three software tools of the *nix Swiss Army knife have to be used:</p>

<ol>
<li><p><code>gparted</code> &ndash; for setting out the partitioning layout;</p></li>
<li><p><code>rsync</code> &ndash; for selectively synchronising the needed data (you can easily decide what to exclude using patterns);</p></li>
<li><p><code>boot-repair</code> &ndash; to fix your Grub2 setup.</p></li>
</ol>


<h3>Partitioning with <code>gparted</code></h3>

<p>Boot your system using your live Ubuntu image. Using <code>gparted</code> (it is included on the live image) create the desired partitions on your SSD. Currently only 2 Linux file systems properly support SSDs (making use of native TRIM): <code>btrfs</code> and <code>ext4</code>. Out of these two, only <code>ext4</code> is considered mature enough to be used on production-ready systems, due to its mass-adoption in the Linux world.</p>

<p>In order to align your partitions with the drive's sectors (for optimal performance and longevity) make sure to leave the first MiB of storage unallocated and to align your partitions to MiB, not cylinders. This is fairly intuitive with <code>gparted</code>.</p>

<p>Remember to add the <code>boot</code> flag to the partition where your <code>/boot</code> folder will be stored.</p>

<h3>Syncing with <code>rsync</code></h3>

<p>Once your SSD drive is partitioned, mount the source and destination partitions. This can easily be done from Nautilus, the default file browser from Ubuntu. Just open the home folder and on the left sidebar you can see the unmounted file systems. Click on them to let the system mount them automatically. I strongly recommend to mount them two by two (1 source, 1 destination) in order to avoid any complications. Using <code>rsync</code> selectively sync your partitions:</p>

<pre><code>    sudo rsync -a -v --exclude "excluded_folder_name_or_pattern" /media/&lt;source_uuid&gt;/ /media/&lt;destination_uuid&gt;
</code></pre>

<h3>Restoring <code>grub</code></h3>

<p>Unfortunately <code>rsync</code> will not be able to handle <code>grub</code>, thus you will not be able to boot your system. Restoring <code>grub</code> is very straight-forward. Again you will need the live CD / live USB stick to boot up your machine. After Ubuntu is up and running from the installation medium, you just need to install and use Boot-Repair. A very good guide is available <a href="https://help.ubuntu.com/community/Boot-Repair" title="Boot-Repair - Ubuntu Community Documentation">here</a>.</p>

<h2>Specific mount options for SSD</h2>

<p>Because of the way SSD drives work, some mount options need to be specified in your <code>/etc/fstab</code> file:</p>

<ul>
<li><code>discard</code> &ndash; this enables <a href="http://en.wikipedia.org/wiki/TRIM" title="TRIM explained on Wikipedia">TRIM</a>;</li>
<li><code>noatime</code> &ndash; this disables pointless writes to disk to store the last accessed time for a read file</li>
</ul>


<p>Your <code>fstab</code> file should look more or less like this:
``` bash</p>

<h1>/etc/fstab: static file system information.</h1>

<p>#</p>

<h1>Use 'blkid -o value -s UUID' to print the universally unique identifier</h1>

<h1>for a device; this may be used with UUID= as a more robust way to name</h1>

<h1>devices that works even if disks are added and removed. See fstab(5).</h1>

<p>#</p>

<h1><file system> <mount point>   <type>  <options>       <dump>  <pass></h1>

<p>proc            /proc           proc    nodev,noexec,nosuid 0       0
UUID=0765430a-83ae-4530-b1b1-a976cd72ce16 /               ext4    discard,noatime,errors=remount-ro             0 1
UUID=263bba00-32f4-4bea-966b-ab7ae1fc3e8b /home           ext4    discard,noatime,errors=remount-ro,user_xattr  0 2
```</p>

<h1>Conclusions</h1>

<p>Migrating from your slow mechanical hard drive was easy. I am pretty sure that  if you have not used a SSD drive until now you will definitely question yourself why it took you so long to switch - I know I do. Sometimes we fail to remember that the hard-disk is still the slowest component in a computing system. A SSD might be the solution to speed up your machine instead of buying the newest and coolest CPU and it's definitely cheaper as long as you can accommodate with less storage space for the drive that should store your OS and applications (and <em>maybe</em> your media workspace).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why awk is better than cut]]></title>
    <link href="https://radu.cotescu.com/why-awk-is-better-than-cut/"/>
    <updated>2011-08-01T12:45:40+03:00</updated>
    <id>https://radu.cotescu.com/why-awk-is-better-than-cut</id>
    <content type="html"><![CDATA[<p>I am currently working with some text files from which I have to extract some data. Generally, when you have to do this kind of work on a *nix machine, you use <code>cut</code> or <code>awk</code>. However, even for simple tasks <code>cut</code> is superseded by the mighty <code>awk</code>. Let's look at the following examples which are closely related to the data that I'm working with. Assume we have the following text file:</p>

<p><code>bash
radu@riker:~$ cat testFile
a
b c
d
e f
</code></p>

<p>What I'd like to do is to extract the strings from each line and assign them to some parameters; obviously the second parameter can be null. To do this with <code>cut</code> you'd have to use two different call types, one for each parameter:</p>

<p><code>bash
radu@riker:~$ cat testFile | cut -d" " -f1
a
b
d
e
radu@riker:~$ cat testFile | cut -d" " -f2 -s
c
f
</code></p>

<p>Notice the <code>-s</code> option in the second call. This tells <code>cut</code> not to print lines not containing delimiters. If by mistake you'd forget to add that flag to the options list, the output would be this:</p>

<p><code>bash
radu@riker:~$ cat testFile | cut -d" " -f2
a
c
d
f
</code></p>

<p>which includes the values for the first parameter too. Not good.</p>

<p>Now let's share some <code>awk</code> love:</p>

<p>``` bash
radu@riker:~$ cat testFile | awk '{print $1}'
a
b
d
e
radu@riker:~$ cat testFile | awk '{print $2}'</p>

<p>c</p>

<p>f
```</p>

<p>Of course, if your restrictions aren't like mine you can as well use <code>cut</code>. However, you'd be safer with <code>awk</code>.</p>

<p>Happy Bash parsing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash one-liner for removing old kernel artefacts]]></title>
    <link href="https://radu.cotescu.com/bash-old-kernel-artefacts/"/>
    <updated>2011-07-29T14:13:57+03:00</updated>
    <id>https://radu.cotescu.com/bash-old-kernel-artefacts</id>
    <content type="html"><![CDATA[<p>Since now I have 4 virtual machines to administer for my dissertation project, I have to find ways to do sysadmin stuff as quickly as possible and to concentrate my efforts on software development. If you ever did a kernel update you would know that a kernel upgrade will not remove the old kernel artefacts, specifically the old headers and the Linux image. While this is a good technique for avoiding incompatibilities of some binaries with the new kernel versions, therefore allowing you to test that everything is working as expected, old kernel images occupy an important amount of space (around 256 MB / release). When your system has a limited amount of storage allocated to it, this might become a problem.</p>

<p>The process of removing the unused images requires a few keystrokes and some user input, needing a great deal of attention not to remove the currently running kernel or - in case you are extremely inattentive - all the kernel images from your system. To semi-automate this task, you can use the following Bash one-liner:</p>

<p><code>bash
sudo apt-get purge $(dpkg -l | grep "^ii" | awk '{print $2}' | egrep -e "^linux-headers-[0-9]|^linux-image-[0-9]" | egrep -v `uname -r | cut -d"-" -f1,2`)
</code></p>

<p>Run this line only after you have booted into your new kernel, otherwise you'll remove the upgrade.</p>
]]></content>
  </entry>
  
</feed>
